# libft

Created: Dec 21, 2020 10:55 AM
Status: In Progress

- Contents

---

- table

    ### prototype

    ```c

    ```

    ### parameter

    ### return val

    ### external func

    ### description

    ### implementation

    ### issue

# 1. Mendatory part

## libft.h

라이브러리

stdlib.h, unistd.h

리스트 구조체

함수 원형

```c

void *ft_memset(void *b, int c, size_t len);
void ft_bzero(void *s, size_t n);
void *ft_memcpy(void *dst, const void *src, size_t n);
void *ft_memccpy(void *dst, const void *src, int c, size_t n);
void *ft_memmove(void *dst, const void *src, size_t len);
void *ft_memchr(const void *s, int c, size_t n);
int ft_memcmp(const void *s1, const void *s2, size_t n);
size_t ft_strlen(const char *s);
size_t ft_strlcpy(void *dst, const void *src, size_t dstsize);
size_t ft_strlcat(void *dst, const void *src, size_t dstsize);
char *ft_strchr(const char *s, int c);
char *ft_strrchr(const char *s, int c);
char *ft_strnstr(const char *haystack, const char *needle, size_t len);
int ft_strncmp(const char *s1, const char *s2, size_t n);
int ft_atoi(const char *str);
int ft_isalpha(int c);
int ft_isdigit(int c);
int ft_isalnum(int c);
int ft_isascii(int c);
int ft_isprint(int c);
int ft_toupper(int c);
int ft_tolower(int c);
void *ft_calloc(size_t count, size_t size);
char *ft_strdup(const char *s1);

char *ft_substr(char const *s, unsigned int start, size_t len);
char *ft_strjoin(char const *s1, char const *s2);
char *ft_strtrim(char const *s1, char const *set);
char **ft_split(char const *s, char c);
char *ft_itoa(int n);
char *ft_strmapi(char const *s, char (*f)(unsigned int, char));
void ft_putchar_fd(char c, int fd);
void ft_putstr_fd(char *s, int fd);
void ft_putendl_fd(char *s, int fd);
void ft_putnbr_fd(int n, int fd);

t_list *ft_lstnew(void *content);
void ft_lstadd_front(t_list **lst, t_list *new);
int ft_lstsize(t_list *lst);
t_list *ft_lstlast(t_list *lst);
void ft_lstadd_back(t_list **lst, t_list *new);
void ft_lstdelone(t_list *lst, void (*del)(void *));
void ft_lstclear(t_list **lst, void (*del)(void *));
void ft_lstiter(t_list *lst, void (*f)(void *));
t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));
```

## memset

### prototype

```c
void *ft_memset(void *b, int c, size_t len);
```

### return value

The memset() function returns its first argument.

### external function

none

### description

 The memset() function writes len bytes of value c (converted to an unsigned char) to the string b.

### implementation

- size_t 사용하려면 stdlib.h 필요

> size_t is an unsigned integral data type which is defined in various header files such as:
<stddef.h>, <stdio.h>, <stdlib.h>, <string.h>, <time.h>, <wchar.h>

[What is the size_t data type in C? - GeeksforGeeks](https://www.geeksforgeeks.org/size_t-data-type-c-language/)

[https://twpower.github.io/79-usage-of-memset-function](https://twpower.github.io/79-usage-of-memset-function)

Q) 주어진 포인터 맨 뒤에 null 을 입력해주어야 하나?

A) 일단 안 붙임

Q) size_t 가 뭐지?

[https://stackoverflow.com/questions/2550774/what-is-size-t-in-c#:~:text=size_t is an unsigned integer data type which can assign,you can run the programm](https://stackoverflow.com/questions/2550774/what-is-size-t-in-c#:~:text=size_t%20is%20an%20unsigned%20integer%20data%20type%20which%20can%20assign,you%20can%20run%20the%20programm).

[https://seoulforest.tistory.com/entry/sizet-타입의-이해](https://seoulforest.tistory.com/entry/sizet-%ED%83%80%EC%9E%85%EC%9D%98-%EC%9D%B4%ED%95%B4)

[https://stackoverflow.com/questions/1119370/where-do-i-find-the-definition-of-size-t](https://stackoverflow.com/questions/1119370/where-do-i-find-the-definition-of-size-t)

[https://en.wikipedia.org/wiki/C_data_types#stddef.h](https://en.wikipedia.org/wiki/C_data_types#stddef.h)

### issues

compile error

```c
ft_memset.c:22:8: error: incomplete type 'void' is not assignable
*b = c;
~~~~ ^

해결법

*(int)b = c; // 실패

b = (unsigned char *)b; // 실패

unsigned char *b_uchar; // 성공: 앞으로 모든 void* 타입 변수의 할당은 unsigned char 로 변환하고서 한다.
b_uchar = b;
```

## bzero

### prototype

```c
void ft_bzero(void *s, size_t len);
```

### return value

no return 

### external function

none

### description

The bzero() function writes n zeroed bytes to the string s.  If n is zero, bzero() does nothing.

### implementation

## memcpy

### prototype

```c
void ft_memcpy(void *dst, const void *src, size_t n);
```

### return value

the original value of dst.

### external function

none

### description

The memcpy() function copies n bytes from memory area src to memory area dst.  If dst and src overlap, behavior is undefined.

### implementation

### issues

```c
ft_memcpy.c:21:12: warning: assigning to 'unsigned char *' from 'const void *' discards qualifiers [-Wincompatible-pointer-types-discards-qualifiers]
        src_uchar = src;

원인

unsigned char *src_uchar;

해결법

const unsigned char *src_uchar; // 성공
```

## memccpy

### prototype

```c
void *ft_memccpy(void * dst, const void  *src, int c, size_t n);
```

### return value

the original value of dst.

### external function

none

### description

The memccpy() function copies bytes from string src to string dst.  If the character c (as converted to an unsigned char) occurs in the string src, the copy stops and a pointer to the byte after the copy of c in the string dst is returned.  Otherwise, n bytes are copied, and a NULL pointer is returned.

### implementation

```c
void  *ft_memccpy(void *dst, const void *src, int c, size_t n)
{
    unsigned char       *dst_uchar;
    const unsigned char *src_uchar;

		if (dst == NULL && src == NULL)
		    return (NULL);
    while (n-- > 0)
    {
				*dst_uchar = *src_uchar;
				if (*src_uchar == (unsigned char)c)
						return (dst + 1);
				dst_uchar++;
				src_uchar++;
				dst++;
    }
    if (n == 0) 
				return (NULL);
}
```

### issues

```c
ft_memccpy.c:33:1: warning: control may reach end of non-void function [-Wreturn-type]
}

원인

if (n == 0) 
		return (NULL);

해결책

while 문을 나오면 n이 0이므로 조건문만 없애기 //성공
```

### ?

```
 The source and destination strings should not overlap, as the behavior is undefined.
```

Q) src 의 처음 n byte 에 c 가 없다면 dest의 n+1 번째 메모리에 null 을 넣어야 하나?

  [http://www.qnx.co.kr/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fm%2Fmemccpy.html](http://www.qnx.co.kr/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fm%2Fmemccpy.html)

A) no

## memmove

### prototype

```c
void *ft_memmove(void *dst, const void *src, size_t len);
```

### return value

The memmove() function returns the original value of dst.

### external function

none

### description

The memmove() function copies len bytes from string src to string dst.  The two strings may overlap; the copy is always done in a non-destructive manner.

### implementation

Q) 겹치는 경우에서 dest 가 src 보다 뒤에 있는 경우

overlap safe

## memchr

### prototype

```c
void *ft_memchr(const void *s, int c, size_t n);
```

### return value

The memchr() function returns a pointer to the byte located, or NULL if no such byte exists within n bytes.

### external function

none

### description

The memchr() function locates the first occurrence of c (converted to an unsigned char) in string s.

### implementation

Q) n byte 전에 s 가 끝나면? 예를 들어 s = 'abc\0i', c = 'i', n = 10

A) 아마도 10 바이트 내에 존재하므로 null값 상관없이 i 주소를 반환해야 될듯

### issues

```c
ft_memchr.c:23:11: warning: returning 'const void *' from a function with result type 'void *' discards qualifiers
      [-Wincompatible-pointer-types-discards-qualifiers]
                        return (s);

원인: s는 const void * 인데 return 타입은 void * 임
해결:
return ((void *)s) //성공 (왜 되는지는 모르겠다.)

```

## memcmp

### prototype

```c
int    ft_memcmp(const void *s1, const void *s2, size_t n);     
```

### return value

The memcmp() function returns zero if the two strings are identical, otherwise returns the difference between the first two differing bytes (treated as unsigned char values, so that `\200' is greater than `\0', for example).  Zero-length strings are always identical. This behavior is not required by C and portable code should only depend on the sign of the returned value.

### external function

none

### description

The memcmp() function compares byte string s1 against byte string s2.  Both strings are assumed to be n bytes long.

### implementation

### issue

- s1 = 'abc\0def', s2= 'abc\0deg', n = 7 이면 -1을 리턴한다.

## strlcpy & strlcat

### prototype

```c
size_t ft_strlcpy(char *dst, const char *src, size_t dstsize);

size_t ft_strlcat(char *dst, const char *src, size_t dstsize);  
```

### return value

Besides quibbles over the return type (size_t versus int) and signal handler safety (snprintf(3) is not entirely safe on some systems), the following two are equivalent:

```
n = strlcpy(dst, src, len);
n = snprintf(dst, len, "%s", src);
```

Like snprintf(3), the strlcpy() and strlcat() functions return the total length of the string they tried to create.  For strlcpy() that means the length of src.  For strlcat() that means the initial length of dst plus the length of src.

 If the return value is >= dstsize, the output string has been truncated.  It is the caller's responsibility to handle this.

### external function

none

### description

The strlcpy() and strlcat() functions copy and concatenate strings with the same input parameters and output result as snprintf(3).  They are designed to be safer, more consistent, and less error prone replacements for the easily misused functions strncpy(3) and strncat(3).
strlcpy() and strlcat() take the full size of the destination buffer and guarantee NUL-termination if there is room.  Note that room for the NUL should be included in dstsize.

strlcpy() copies up to dstsize - 1 characters from the string src to dst, NUL-terminating the result if dstsize is not 0.
strlcat() appends string src to the end of dst.  It will append at most dstsize - strlen(dst) - 1 characters.  It will then NUL-terminate, unless dstsize is 0 or the original dst string was longer than dstsize (in practice this should not happen as it means that eitherdstsize is incorrect or that dst is not a proper string).
If the src and dst strings overlap, the behavior is undefined.

### implementation

### issues

```c
ft_strlcpy.c:20:2: error: statement requires expression of scalar type ('void' invalid)
        while (*s++)
        ^      ~~~~

ft_strlcpy.c:30:9: warning: assigning to 'void *' from 'const void *' discards qualifiers [-Wincompatible-pointer-types-discards-qualifiers]
        srctmp = src;
               ^ ~~~
ft_strlcpy.c:33:10: error: incomplete type 'void' is not assignable
                *dst++ = *src++;
                ~~~~~~ ^
ft_strlcpy.c:34:7: error: incomplete type 'void' is not assignable
        *dst = 0;

원인

void *s 이므로.. 근데 scalar type 이 뭘까?
void *src, *dst 

해결

unsigned char 변수 선언해서 복사
```

- scalar data type

[Scalar Data Types](https://link.springer.com/chapter/10.1007%2F978-1-4612-4020-4_4)

## strchr & strcchr

### prototype

```c
char *ft_strchr(const char *s, int c);
char *ft_strrchr(const char *s, int c);
```

### return value

The functions strchr() and strrchr() return a pointer to the located character, or NULL if the character does not appear in the string.

### external function

none

### description

The strchr() function locates the first occurrence of c (converted to a char) in the string pointed to by s.  The terminating null character is considered to be part of the string; therefore if c is '\0', the functions locate the terminating '\0'.

The strrchr() function is identical to strchr(), except it locates the last occurrence of c.

### implementation

## strnstr

### prototype

```c
char *ft_strnstr(const char *haystack, const char *needle, size_t len);
```

### return value

If needle is an empty string, haystack is returned; if needle occurs nowhere in haystack, NULL is returned; otherwise a pointer to the first character of the first occurrence of needle is returned.

### external function

none

### description

The strnstr() function locates the first occurrence of the null-terminated string needle in the string haystack, where not more than len characters are searched.  Characters that appear after a `\0' character are not searched.  Since the strnstr() function is a FreeBSD specific API, it should only be used when portability is not a concern.

### implementation

### issues

- const char* → char*

## strncmp

### prototype

```c
int ft_strncmp(const char *s1, const char *s2, size_t n);
```

### return value

The strncmp() function compares not more than n characters.  Because strncmp() is designed for comparing strings rather than binary data, characters that appear after a `\0' character are not compared. -> memcmp에서 '\0' 을 고려해야 한다는 것을 의미하는 것 같다.

### external function

none

### description

The strcmp() and strncmp() functions return an integer greater than, equal to, or less than 0, according as the string s1 is greater than, equal to, or less than the string s2.  The comparison is done using unsigned characters, so that '\200' is greater than '\0'.

### implementation

## atoi

### issue

```c
static intft_isspace(const char c)
{
    return ((c == ' ' || (c >= 9 && c <= 13)) ? 1 : 0);
}

int ft_atoi(const char *str)
{
    long long   sign;
    long long   result;
    size_t      i;

		i = 0;
    while (ft_isspace(str[i]))
				i++;
    sign = 1;
    if (str[i] == '-')
				sign = -1;
    i++; // 부호가 없는 경우 첫 숫자를 넘어간다.
    result = 0;
    while (str[i] >= '0' && str[i] <= '9')
    {
				result += str[i] - 48;
				result *= 10; // 이걸 먼저 
				i++;
		}
    result *= sign;
		return ((int)result);
} // -1 인 경우 -10 나옴
// 부호가 없는 경우는 어떡할까?
if (str[i] == '-' || str[i] == '+')
{
		if (str[i] == '-')
				sign = -1;
		i++;
}// 성공
```

## calloc

### prototype

```c
void *calloc(size_t count, size_t size);
```

### return value

If successful, calloc(), malloc(), realloc(), reallocf(), and valloc() functions return a pointer to allocated memory.  If there is an error, they return a NULL pointer and set errno to ENOMEM.

### external function

malloc (<stdlib.h>)

### description

The calloc() function contiguously allocates enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory.  The allocated memory is filled with bytes of value zero.

### implementation

errno = ENOMEM;

```c
#include "libft.h"
#include <errno.h>

static void ft_bzero(void *s, size_t n)
{
    unsigned char *s_uchar;

		s_uchar = s;
    while (*s_uchar)
				*s_uchar++ = 0;
}

void *ft_calloc(size_t count, size_t size)
{
    void *buffer;

		if ((buffer = malloc(count * size)) == NULL)
    {
				errno = ENOMEM; // 삭제
				return (NULL);
    }
    else
    {
				ft_bzero(buffer, count * size);
				return (buffer);
    }
}
```

### issues

- errno 와 ENOMEM은 무슨 의미인가?

[errno 변수로 오류처리 하기](https://m.blog.naver.com/PostView.nhn?blogId=neakoo35&logNo=30125432098&proxyReferer=https:%2F%2Fwww.google.com%2F)

```c
ft_calloc.c:16:38: error: unused parameter 'n' [-Werror,-Wunused-parameter]
static void     ft_bzero(void *s, size_t n)
                                         ^

해결

while (n-- > 0)
// -> libft.h 에 모든 함수들의 원형을 넣는 것으로 이미 구현한 함수의 static 버전을 만들지 않기로 함
```

## strdup

### prototype

```c
char *ft_strdup(const char *s1);
```

### external function

malloc

### description

The strdup() function allocates sufficient memory for a copy of the string s1, does the copy, and returns a pointer to it.  The pointer may subsequently be used as an argument to the function free(3). If insufficient memory is available, NULL is returned and errno is set to ENOMEM.

### implementation

ft_strlen, ft_strlcpy 사용

## substr

### prototype

```c
char *ft_substr(char const *s, unsigned int start, size_t len);
```

### parameter

#1. The string from which to create the substring.
#2. The start index of the substring in the string ’s’.
#3. The maximum length of the substring.

### return val

 The substring. NULL if the allocation fails.

### external func

malloc

### description

Allocates (with malloc(3)) and returns a substring from the string ’s’.
The substring begins at index ’start’ and is of maximum size ’len’.

### implementation

Q) const 위치에 따른 의미

[https://simplesolace.tistory.com/entry/c-항상-헷갈리는-const-위치에-따른-쓰임새-차이-const-char-char-const](https://simplesolace.tistory.com/entry/c-%ED%95%AD%EC%83%81-%ED%97%B7%EA%B0%88%EB%A6%AC%EB%8A%94-const-%EC%9C%84%EC%B9%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%93%B0%EC%9E%84%EC%83%88-%EC%B0%A8%EC%9D%B4-const-char-char-const)

Q) start + len 이 s 를 넘어가는 경우는 어떻게 해야하나?

A) len 이 maximum 이므로 s의 null 이 나올 때 까지만 복사함

Q) iterate by index or with pointer? 정확한 답을 알고 싶다.

[How can I best iterate over a C array? With pointers or by index?](https://stackoverflow.com/questions/36930426/how-can-i-best-iterate-over-a-c-array-with-pointers-or-by-index)

A) stirng.h 함수들을 만드는 입장에서는 string 의 시작 주소를 반환해야하는 경우에 포인터로 접근하도록 구현하면 시작 주소 포인터를 따로 선언해주어야 한다. 그러므로 index로 하는 것이 더 낫지 않을까 생각해본다. 별개로 string을 만들 때 char s[10] 과 char *s 가 어떻게 다른지에 대한 설명도 보게 되었다.

[What's difference between char s[] and char *s in C? - GeeksforGeeks](https://www.geeksforgeeks.org/whats-difference-between-char-s-and-char-s-in-c/)

## strtrim

### prototype

```c

```

### parameter

### return val

### external func

### description

### implementation

고려사항:
1. 일반적인 케이스: set 글자들이 앞 뒤에 붙어 있는 형태
2. set 글자가 없는 형태
3. set 글자만 있는 형태
4. 한 글자 or null
5. s1 이나 set 이 NULL
6. malloc 길이 == index 차이 + 1 (-> 총 글자수) + 1 (->null)
7. 처음과 끝 index 찾기: 
    s1 전체를 순회하다가 처음 nonset 일 때만 업데이트(처음 업데이트인지 알 수 있는 변수 하나가 더 필요함)
    -> 처음 nonset 나올 때까지만 순회
8. norminette: 변수명 바꾸고 첫 두 while 문에서 i 대신 처음 끝 변수를 사용해서 i 업데이트 줄임

Q) s1에서 set 글자들을 모두 지워야 하나? 아니면 처음과 끝만 해당되나? 예를 들어 s1 = "setHsetHset", set = "set" 이면 결과는 "HH" 인가? "HsetH" 인가?

A) HsetH

## split

### implementation

```c
#include "libft.h"

static size_t split_length(char const *s, char c)
{
	size_t split_len;
	size_t i;

	i = 0;
	split_len = 0;
	if (i == 0 && s[i] == c) // 처음
		i++;
	while (s[i])
	{
		if (s[i] == c && s[i - 1] != c) // 중간
			split_len++;
		else if (s[i + 1] == 0 && s[i] != c) // 마지막 c 이후
			split_len++;
		i++;
	}
	return (split_len);
}

static void malloc_strs(char const *s, char c, 
			char **split, size_t split_len)
{
	size_t i;
	size_t j;
	size_t k;

	i = 0; // s 인덱스
	j = 0; // string 길이
	k = 0; // split 인덱스
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c && s[i]) // 구분자 아닌 구간
		{
			i++;
			j++;
		}
		if (s[i] == c || s[i] == 0) // (각 string 끝났을 때) or (s 가 끝났을 때)
		{
			split[k] = malloc(sizeof(char) * (j + 1));
			j = 0;
			i++;
			k++;
		}
	}
}

static void fill_strs(char const *s, char c, char **split, size_t split_len)
{
	size_t i; // s 인덱스
	size_t j; // string 인덱스
	size_t k; // split 인덱스

	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c && s[i]) // 구분자 아닌 구간
		{
			split[k][j] = s[i];
			j++;
			i++;
		}
		split[k][j] = 0; // null문자 
		j = 0;
		k++;
		i++;
	}
	split[k] = NULL; // split 끝부분
}

char **ft_split(char const *s, char c)
{
	char **split;
	size_t split_len;

	split_len = split_length(s, c);
	split = malloc(sizeof(char *) * (split_len + 1));
	malloc_strs(s, c, split, split_len);
	fill_strs(s, c, split, split_len);
	return (split);
}
```

( *s 를 순회 ( delimiter 가 나올 때까지 순회 + malloc & 스트링 만들기 ) ) 

→ split_len 길이 구하고 malloc, 각 string 길이 구하고 malloc & 채우기

- 고려사항

case:  ("ccccabdccxyzccc", 'c'), ("ccccabdccxyz", 'c'), ("      ", ' '), ("abcde", 'z')

 1. split_len 길이 구하고 malloc
~~split_len == (c 개수 + 1)~~
split_len == (c 사이의 길이가 0이 아닌 str 개수)

→ 처음: 구분자가 나오면 넘어감

→ 중간: 현재가 구분자, 바로 전이 구분자가 아닐 때만 유효

→ 끝: 마지막 문자가  구분자가 아닌 경우는 마지막 구분자 이후에 문자들이 있는 경우이므로 "중간" 에서 고려되지 못함

~~split 길이는 split_len 인데 null string을 뒤에 넣는다고 잘못 생각해서 split_len + 1 크기만큼 malloc 했다.~~
-> split 길이는 split_len + 1 이고 마지막 split[n]은 첫 글자가 null인 string이 아닌 null 값을 가져야 한다.

2. 각  string malloc

i : *s 인덱스

j : 만들 string 길이

k : string 개수 인덱스

→ 구분자가 아닌 구간의 길이를 재서 메모리 할당, '\0' 추가

3. 각 string 채우기

→ 구분자 아닌 구간에만 while 문으로 채우기, '\0' 추가

- 궁금한 부분 : 'c' 가 연속으로 나오면 그 사이의 크기가 0인 str을 만들어야 하는가? 아니다.

pin

## itoa

### issue

```c
ft_itoa.c:36:35: error: invalid operands to binary expression ('unsigned long' and 'size_t (int)' (aka 'unsigned long (int)'))
if ((n_str = malloc(sizeof(char) * nlen + 1)) == NULL)
										~~~~~~~~~~~~ ^ ~~~~

원인: 값 자리에 함수이름 씀(c 언어에서 함수도 값인가?)
ft_itoa.c:40:15: warning: incompatible pointer to integer conversion assigning to 'char' from 'void *' [-Wint-conversion]
n_str[len--] = NULL;
						 ^ ~~~~
```

## strmapi

### prototype

```c
char *ft_strmapi(char const *s, char (*f)(unsigned int, char))
```

### implementation

- Q) const 위치에 따른 의미

[https://simplesolace.tistory.com/entry/c-항상-헷갈리는-const-위치에-따른-쓰임새-차이-const-char-char-const](https://simplesolace.tistory.com/entry/c-%ED%95%AD%EC%83%81-%ED%97%B7%EA%B0%88%EB%A6%AC%EB%8A%94-const-%EC%9C%84%EC%B9%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%93%B0%EC%9E%84%EC%83%88-%EC%B0%A8%EC%9D%B4-const-char-char-const)

- Q) f 의 첫 인자는 s 의 인덱스인가?

매개변수로 쓰이는 함수 포인터

[https://dojang.io/mod/page/view.php?id=599](https://dojang.io/mod/page/view.php?id=599)

- Q) 왜 f 가 아닌 *f 인가? 함수도 메모리에 저장되어 있는건가?

### issue

# 2. Bonus part

## lstnew

### prototype

```c
t_list *ft_lstnew(void *content);
```

### implementation

- Q) t_list malloc 크기

    A) [https://dojang.io/mod/page/view.php?id=418](https://dojang.io/mod/page/view.php?id=418)

- Q) content 도 malloc 해야 하나?

    A) NO.

- content 를 lst→content 로 복사할 때 ft_memmove 사용 → 그렇게 안해도 됨 (lst→content = content)

### issue

```c
ft_lstnew.c:32:2: error: variable 'lst' is uninitialized when used here [-Werror,-Wuninitialized]
        lst->next = NULL;
        ^~~
ft_lstnew.c:29:15: note: initialize the variable 'lst' to silence this warning
        t_list                  *lst;
                                    ^
                                     = NULL

원인:
lst 를 선언 후 초기화 안해서.
왜 lst를 초기화해야하지?
```

## lstadd_front

Q) lst의 first link 는 head 인가 아니면 content 를 가진 노드인가?

A) 후자

## lstsize & lstlast

- Q) 왜 순회용 포인터를 따로 선언해야 하나?

    A) 리스트 포인터를 복사하지 않고 옮기면 첫 노드를 가리킬 방법이 없어지기 때문인듯 하다. 

## lstadd_back

연결리스트 탐색하는 포인터로 다음 노드가 NULL인 노드까지 온 후 new 노드를 붙인다. 

- (lst ≠ 0 && *lst == 0)인 경우 첫 노드가 new 가 됨 → 이런 경우가 가능한가?

```c
void ft_lstadd_back(t_list **lst, t_list *new);
```

## lstdelone

### implementation

void (*del)(void *)

```c
del(lst -> content)

/*  Takes as a parameter an element and frees the
**  memory of the element’s content using the function
**  ’del’ given as a parameter and free the element.
**  The memory of ’next’ must not be freed.
*/
```

del 이 삭제 함수이다.

Q) del은 어떻게 구현되어 있을까? content는 왜 node 와 같이 free 를 사용하지 않나?

A) frees the memory of the element’s content using the function ’del’ 라고 하니 free 를 사용하여 구현 되어 있을 듯 하다. node 를 free 하기 전에 content 를 먼저 해야 하기 때문

## lstclear

### implementation

(현재 노드, 다음 노드 저장 → 현재 노드의 content del, 노드 free → 다음 노드를 현재노드로)(다음 노드 NULL 일 때까지) → 현재 노드의 content del, 노드 free, lst = NULL로 변경

첫노드가 head(내용없음) 가 아니라 가정하고 코딩

→ 순회용 포인터로 처음부터 ft_lstdelone을 사용하여 삭제함, 미리 저장해둔 다음 노드로 옮겨서 반복, 첫 노드는 내용있는 노드가 맞았음

## lstiter

Q) ft_lstdelone 과 비교하면 del 함수가 f 로 바뀌고 free 하지 않는 것이 다르다. 왜 순회용 포인터를 따로 만들어야 할까?

## lstmap

### implementation

- 처음 - 기존 리스트를 없애야 하는 것으로 잘못 이해함.

```c
#include "libft.h"

static voidcreate_node(t_list *lst, t_list *map_lst, void *(*f)(void *), void (*del)(void *));

static size_tcontent_len(void *content)
{
  size_t len;

	len = 0;
	while (*content++)
		len++;
	return (len);
}

t_list*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list *iter;
	t_list *lst_next;
	t_list *map_lst;
	t_list *map_lst_first;
	t_list *store_next;

	iter = lst;
	if ((map_lst = malloc(sizeof(t_list))) == NULL)
		return (NULL);
	map_lst_first = map_lst;
	while (iter -> next != NULL)
	{
		if ((map_lst -> next = malloc(sizeof(t_list))) == NULL)
			return (NULL);
		if ((map_lst -> content = malloc(content_len(iter -> content) + 1)) = NULL)
			return (NULL);
		map_lst -> next = iter -> next;
		map_lst -> content = f(iter -> content);
		map_lst = map_lst -> next;
		iter = iter -> next;
		del(lst -> content);
		store_next = lst -> next;
		free(lst);
		lst = store_next;
	}
	if ((map_lst -> content = malloc(content_len(iter -> content) + 1)) = NULL)
		return (NULL);
	map_lst -> next = NULL;
	map_lst -> content = f(iter -> content);
	del(lst -> content);
	free(lst);
	return (map_lst_first);
}
```

- 두번째

```c
#include "libft.h"

t_list      *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
    t_list  *newlst;
    t_list  *newlst_iter;

		newlst = ft_lstnew(f(lst->content));
    newlst_iter = newlst;
    lst = lst->next;
    while (*lst)
    {
				if ((newlst_iter->next = ft_lstnew(f(lst->content))) == NULL)
				{vim 
						ft_lstclear(&newlst, del); // lst 로 잘못 적어놓음
						return (0);
				}
				newlst_iter = newlst_iter->next;
				lst = lst->next;
    }
    return (newlst);
}
```

Q) 새 list 를 만들어야 하나?

A) yes

Q) 기존 리스트의 내용만 바꾼다면 del은 기존 content 를 지우기 위해 사용하는건가? 기존 리스트를 free 해야 하나?

A) 기존 리스트를 free 했다. → 기존 리스트를 free 할 필요는 없다. **free와 del 은 새 리스트를 동적할당하다가 실패할 경우 지금까지 만든 새 리스트를 모두 지우는 용도로 쓴다.**

```c
t_list *iter;//순회용 포인터
t_list *map_lst;// 결과 저장할 리스트 포인터
t_list *map_lst_first;// return 할 첫 노드
```

주어진 리스트를 순회하면서 새 리스트 노드 할당 및 f(content) 를 저장, lst 현재 노드 free

새 리스트의 첫 노드 리턴

### 메모리 할당

Q) head 만 할당하나? 길이를 구해서 전체를 할당해야 하나?

A) while 문으로 하나씩 할당

Q) content 는 어떻게 메모리 할당해야 하나?( 구조체 메모리 할당)

struct malloc , automatic and dynamic memory allocation

[https://stackoverflow.com/questions/29522264/correct-way-to-use-malloc-and-free-with-linked-lists](https://stackoverflow.com/questions/29522264/correct-way-to-use-malloc-and-free-with-linked-lists)

- ft_lstnew, ft_lstclear 사용

### issue

```c
ft_lstmap.c:23:2: error: statement requires expression of scalar type ('t_list' (aka 'struct s_list') invalid)
        while (*lst)
        ^      ~~~~
원인:
*lst 는 리스트 자체임
lst로 고침
```

# makefile

[https://velog.io/@hidaehyunlee/Makefile-만들기](https://velog.io/@hidaehyunlee/Makefile-%EB%A7%8C%EB%93%A4%EA%B8%B0)

- phony rule

# test

## libftest

[[Libft] Test Program](https://velog.io/@hidaehyunlee/Libft-Test-Program)

[GNU Make 강좌: make 수행 시에 나타나는 에러들](http://doc.kldp.org/KoreanDoc/html/GNU-Make/GNU-Make-8.html)

### issues

```c
ls
$> make re
Makefile:53: *** commands commence before first target.  Stop.

원인(아마도)

위의 에러는 '첫 번째 타겟이 나오기 전에 명령어가 시작되었다'는 애매한 에러 메시지이다.
필자가 경험한 이 에러의 원인은 주로 긴 문장을 여러 라인에 표시를 하기 위해서 '\'를 사용할 때,
이를 잘못 사용했기 때문인 것 같다. 즉 '\'부분은 라인의 가장 끝문자가 되어야 하는데
실수로 '\'뒤에 스페이스를 몇 개 집어넣으면 여지없이 위의 에러가 발생한다.
```

```c
Undefined symbols for architecture x86_64:
  "_main", referenced from:
implicit entry/start for main executable
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [ft_lstnew.o] Error 1

원인 
모름

해결책
Makefile 에서 FLAG 에 -c 추가하니까 됨
```

[Compile error: Undefined symbols: "_main", referenced from: start in crt1.10.5.o](https://stackoverflow.com/questions/550455/compile-error-undefined-symbols-main-referenced-from-start-in-crt1-10-5-o)

- test bonus

```c
FUNCTION      NORME COMPIL.FORBIDDEN FUNC. TESTS    RESULT
ft_lstadd_back  ok success clean             S       KO
ft_lstadd_front ok success clean             ✓       OK
ft_lstclear     ok success clean             ✓       OK
ft_lstdelone    ok success clean             ✓       OK
ft_lstiter      ok success clean             ✓       OK
ft_lstlast      ok success clean             ✓✗     KO
ft_lstmap       ok success clean             ✓       OK
ft_lstnew       ok success clean             ✓✓✓    OK
ft_lstsize      ok success clean             ✗✗S    KO

void  ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list *last;

	if (lst == 0 || new == 0)
		return ;
	else if (*lst == 0)
	{
		*lst = new;
		return ;
	}
	last = ft_lstlast(*lst);
	last->next = new;
}

t_list  *ft_lstlast(t_list *lst)
{
	t_list *iter;

	iter = lst->next; // iter = lst;
	while (iter != NULL)
	{
		if (iter->next == NULL)
			return (iter);
		iter = iter->next;
	}
	return (NULL);
}

int  ft_lstsize(t_list *lst)
{
	t_list *iter;
	int len;

	iter = lst->next; // iter = lst;
	len = 0;
	while (iter != NULL)
	{
		iter = iter->next;
		len++;
	}
	return (len);
}
// 해결
```

- test 오류 - part 1, 2 모두 NTI(nothing turned in)

```c
Makefile 에서 
re: fclean all -> re: clean all 로 바꾸니까 됨
```

- test mandatory

```c
FUNCTION    NORME COMPIL. FORBIDDEN FUNC.  TESTS          RESULT
ft_atoi     ok    success clean ✓✗✗✗✗✗✓✓✓✓✗✗✗✗✗✗✗✗✓KO    
ft_bzero    ok    success clean ✗✓                         KO
ft_calloc   ok    success clean ✗                          KO
ft_strchr   ok    success clean ✓✓✓✗✓✓     KO
ft_strlcat  ok    success clean ✗✗✗✗✓✓✓✓✓            KO
ft_strlcpy  ok    success clean ✓✓✓✓✗      KO
ft_strncmp  ok    success clean ✓✓✓✓✓✓✓✗✗✗✓    KO
ft_strnstr  fail  success clean ✗✗✗✓✓✗✓✓✗✓    KO
ft_strrchr  ok    success clean ✓✓✓✓✗✗✗✗        KO
ft_isalnum  ok    success clean ✓✓✓✓✓✓✓    OK
ft_isalpha  ok    success clean ✓✓✓✓✓✓✓    OK
ft_isascii  ok    success clean ✓✓✓✓✓✓✓    OK
ft_isdigit  ok    success clean ✓✓✓✓✓✓✓    OK
ft_isprint  ok    success clean ✓✓✓✓✓✓✓    OK
ft_memccpy  ok    success clean ✓✓✓✓        OK
ft_memchr   ok    success clean ✓✓✓✓✓✓     OK
ft_memcmp   ok    success clean ✓✓✓✓✓✓✓✓✓ OK
ft_memcpy   ok    success clean ✓✓✓         OK
ft_memmove  ok    success clean ✓✓✓✓✓      OK
ft_memset   ok    success clean ✓✓✓✓        OK
ft_strdup   ok    success clean ✓            OK
ft_strlen   ok    success clean ✓✓✓✓✓✓     OK
ft_tolower  ok    success clean ✓✓✓✓✓✓✓    OK
ft_toupper  ok    success clean ✓✓✓✓✓✓✓    OK

Total : 15/24

Part2 functions

FUNCTIONNORMECOMPIL.FORBIDDEN FUNC.TESTSRESULT
ft_itoa ok success clean ✗✓✗✓✗✓✗✓✗✓ KO
ft_putchar_fd ok success clean✓✓✓✓✓✓✓ OK
ft_putendl_fd ok success clean✓✓✓✓ OK
ft_putnbr_fd ok success clean✓✓✗✓✗✓✗✓✗ KO
ft_putstr_fd ok success clean✓✓✓✓ OK
ft_split fail success clean✗✗✗✗B KO
ft_strjoin ok success clean✓✓✓✓ OK
ft_strmapi ok success clean✓ OK
ft_strtrim fail success clean✗✗✗✗✗ KO
ft_substr ok success clean✓✓✓✓ OK

Total : 6/10
```

- part1 고치기

```c
static intft_isspace(const char c)
{
    return ((c == ' ' || (c >= 9 && c <= 13)) ? 1 : 0);
}

int ft_atoi(const char *str)
{
    long long   sign;
    long long   result;
    size_t      i;

		i = 0;
    while (ft_isspace(str[i]))
				i++;
    sign = 1;
    if (str[i] == '-')
				sign = -1;
    i++; // 부호가 없는 경우 첫 숫자를 넘어간다.
    result = 0;
    while (str[i] >= '0' && str[i] <= '9')
    {
				result += str[i] - 48;
				result *= 10; // 이걸 먼저 
				i++;
		}
    result *= sign;
		return ((int)result);
} // -1 인 경우 -10 나옴
// 부호가 없는 경우는 어떡할까?
if (str[i] == '-' || str[i] == '+')
{
		if (str[i] == '-')
				sign = -1;
		i++;
}// 성공

void ft_bzero(void *s, size_t n)
{
    unsigned char   *s_uchar;

    s_uchar = s;
    while (n-- > 0)
				*s_uchar = 0; // *s_uchar++ = 0; 성공
}

ft_calloc // ft_bzero 오류를 고치니 성공 
ft_strchr ft_strcchr // 포인터 접근하지 않고 인덱스로 접근하니 오류 없음, s 를 옮겨서 나는 오류같다
ft_strlcat // while 문에서 src가 끝나는 경우를 넣음
ft_strlcpy // dstsize가 0 이하인 경우에 *dst_uchar = 0 하지 않고 바로 return. 

int ft_strncmp(const char *s1, const char *s2, size_t n)
{
    while (*s1 && *s2 && (n-- > 0) && (*s1 == *s2)) // --n 으로 고쳐서 n번째 인덱스 값의 차를 반환하도록 함. 그래도 실패
    {
				s1++;
				s2++;
    }
    return ((unsigned char)*s1 - (unsigned char)*s2);
}
// hellz hello 4
// h h 3 1 1
// e e 2 2 2
// l l 1 3 3
// l l 0 4 4
// 'z' - 'o' != 0 실패

// --n 으로 고친 후

// hellz hello 6
// h h 5 1 1
// e e 4 2 2
// l l 3 3 3
// l l 2 4 4
// z o 1 4 4
// 'z' - 'o' 성공

// hello hel 5
// h h 4 1 1
// e e 3 2 2
// l l 2 3 3
// l \0 1 4 4 성공

// n == 0 이면 어떻게 하나?
// abc def 0
// a - d != 0 실패. 따로 고려해줘야 함

int ft_strncmp(const char *s1, const char *s2, size_t n)
{
    size_t  i;

		i = 0;
		if (n == 0)
				return (0);
    while (s1[i] && s2[i] && (i < n - 1) && (s1[i] == s2[i]))
				i++;
    return ((unsigned char)s1[i] - (unsigned char)s2[i]);
} // 성공

ft_strnstr
// len 이 haystack 보다 긴 경우를 위해 while 문 조건에 hyastack이 끝나기 전 조건을 넣음
```

- part2

```c
ft_itoa
// 고려사항
// 에러: n_len == 0 or n_str의 메모리 할당 실패 
// n == 0 인 경우, while 문 전에 string 만들기
// n < 0 인 경우, n_len 길이 하나 추가, string 첫 글자에 '-' 넣고 양수로 변환(ln = -ln)해서 while 문 들어가기
// n 이 intmax 인 경우, long ln = n
// while 문에서는 양수인 ln에 대해서만 고려한다.

static size_t   number_len(int n)
{
    size_t  len;

		len = 0;
    if (n < 0)
				len++;
    if (n == 0)
				return (1);
    while (n != 0)
    {
				n /= 10;
				len++;
    }
    return (len);
}

char*ft_itoa(int n)
{
    char    *n_str;
    size_t  n_len;
    long    ln;

		n_len = number_len(n);
		if (n_len == 0)
				return (NULL);
		if ((n_str = malloc(sizeof(char) * n_len + 1)) == NULL)
				return (NULL);
		ln = n;
		if (n < 0)
		{
				n_str[0] = '-';
				ln = -ln;
		}
		n_str[n_len--] = '\0';
		if (ln == 0)
				n_str[n_len] = '0';
		while (ln > 0)
		{
				n_str[n_len--] = (ln % 10) + 48;
				ln /= 10;
		}
		return (n_str);
}

ft_putnbr_fd
// n < 0 인 경우 양수로 바꾼 뒤 재귀문을 실행해야 하므로 else if 를 if 로 바꿈
// else 문에서 n 이 아니라 ln으로 호출해야 함

 
```

```c
ft_split
//

ft_strtrim

ft_strtrim.c:51:34: warning: unsequenced modification and access to 'i' [-Wunsequenced]
                trimstr[i] = s1[trim_start + (i++)];
원인: 예상치 못한 결과 발생 가능

// 첫 시도
char			*ft_strtrim(char const *s1, char const *set)
{
	char	*trimstr;
	size_t	first_nonset_idx;
	size_t	last_nonset_idx;
	size_t	idx;
	size_t	s1len;

	s1len = ft_strlen(s1);
	idx = 0;
	first_nonset_idx = 0;
	last_nonset_idx = 0;
	while (idx < s1len)
	{
		if (char_in_set(s1[idx], set) == 0 && first_nonset_idx == 0)
			first_nonset_idx = idx;
		idx++;
	}
	idx = s1len;
	while (idx > 0)
	{
		if (char_in_set(s1[idx - 1], set) == 0 && last_nonset_idx == 0)
			last_nonset_idx = idx - 1;
		idx--;
	}
	if (first_nonset_idx >= last_nonset_idx)
		return (NULL);
	if ((trimstr = malloc(sizeof(char) * (last_nonset_idx - first_nonset_idx))) == NULL)
		return (NULL);
	idx = 0;
	while (idx <= last_nonset_idx - first_nonset_idx)
	{
		trimstr[idx] = s1[first_nonset_idx + idx];
		idx++;
	}
	return (trimstr);
}

// 고려사항:
// 1. 일반적인 케이스: set 글자들이 앞 뒤에 붙어 있는 형태
// 2. set 글자가 없는 형태
// 3. set 글자만 있는 형태
// 4. 한 글자 or null
// 5. s1 이나 set 이 NULL
// 5. malloc 길이 == index 차이 + 1 (-> 총 글자수) + 1 (->null)
// 6. 처음과 끝 index 찾기: 
//    s1 전체를 순회하다가 처음 nonset 일 때만 업데이트(처음 업데이트인지 알 수 있는 변수 하나가 더 필요함)
//    -> 처음 nonset 나올 때까지만 순회
// 7. norminette: 변수명 바꾸고 첫 두 while 문에서 i 대신 처음 끝 변수를 사용해서 i 업데이트 줄임 

char *ft_strtrim(char const *s1, char const *set)
{
    char    *trimstr;
    size_t  trim_start;
    size_t  trim_end;
    size_t  i;
    size_t  s1len;

		s1len = ft_strlen(s1);
    trim_start = 0;
    trim_end = s1len - 1;
    while (trim_start < s1len && char_in_set(s1[trim_start], set) == 1)
				trim_start++;
    while (trim_end >= 0 && char_in_set(s1[trim_end], set) == 1)
				trim_end--;
    if (trim_start > trim_end)
				return (NULL);
    if ((trimstr = malloc(sizeof(char) * (trim_end - trim_start + 2))) == NULL)
				return (NULL);
    i = 0;
    while (i <= trim_end - trim_start)
    {
				trimstr[i] = s1[trim_start + i];
				i++;
    }
    trimstr[i] = 0;
    return (trimstr);
}

```

[증감연산자에대한 질문입니다.](https://kldp.org/node/157199)

[Undefined behavior and sequence points](https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points)

```c

//------------------------------------------------------------------
ft_substr
// 고려하지 않은 케이스 *s=="lorem ipsum dolor sit amet", start==400, len==20
// NULL 반환해서 틀림
// 크기 1인 string을 malloc 하고 null 로 초기화 후 주소 반환하니 성공

//------------------------------------------------------------------

ft_split
// 첫 시도

static size_t	num_of_str(char const *s, char c)
{
	size_t	count;
	size_t	index;

	count = 0;
	index = 0;
	while (s[index])
	{
		if (s[index] == c)
			count++;
		index++;
	}
	return (count + 1);
}

static size_t	len_of_str(char const *s, char c, size_t start_index)
{
	size_t	len;

	len = 0;
	while (s[start_index + len] != c)
		len++;
	return (len);
}

char			**ft_split(char const *s, char c)
{
	char	**s_split;
	size_t	split_len;
	size_t	s_len;
	size_t	one_str_len;
	size_t	split_index;
	size_t	s_index;
	size_t	i;

	s_len = ft_strlen(s);
	split_len = num_of_str(s, c);
	if ((s_split = malloc(sizeof(char *) * split_len + 1)) == NULL)
		return (NULL);
	one_str_len = 0;
	split_index = 0;
	s_index = 0;
	i = 0;
	while (split_index < split_len)
	{
		one_str_len = len_of_str(s, c, s_index);
		s_index += one_str_len;
		if ((s_split[split_index] = malloc(sizeof(char) * one_str_len + 1)) == NULL)
			return (NULL);
		while (i < one_str_len)
		{
			s_split[split_index][i] = s[s_index + i];
			i++;
		}
		s_split[split_index][i] = '\0';
		i = 0;
		one_str_len = 0;
		split_index++;
	}
	s_split[split_index] = NULL;
	return (s_split);
}

//-------------------------------------------------------

static size_t	split_length(char const *s, char c)
{
	size_t	split_len;
	size_t	i;

	i = 0;
	split_len = 0;
	if (i == 0 && s[i] == c)
		i++;
	while (s[i])
	{
		if (s[i] == c && s[i - 1] != c)
			split_len++;
		else if (s[i + 1] == 0 && s[i] != c)
			split_len++;
		i++;
	}
  printf("split_len : %zu\n", split_len);
	return (split_len);
}

static void		malloc_strs(char const *s, char c,
		char **split, size_t split_len)
{
	size_t	i;
	size_t	j;
	size_t	k;

	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c) // s[i] == 0 에서 안 끝남
		{
			i++;
			j++;
		}
		if (s[i] == c) // 마지막 c 이후의 string 을 고려하지 못함
		{
			split[k] = malloc(sizeof(char) * (j + 1));
			printf("%zu\n", j);
      j = 0;
			i++;
			k++;
		}
	}
	//split[k] = malloc(sizeof(char) * (j + 1));
}

static	void	fill_strs(char const *s, char c, char **split, size_t split_len)
{
	size_t	i;
	size_t	j;
	size_t	k;

	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c)
		{
			split[k][j] = s[i];
			j++;
			i++;
		}
		if (s[i] == c)
		{
			j = 0;
			k++;
			i++;
		}
	}
	split[k] = NULL;
}

char			**ft_split(char const *s, char c)
{
	char	**split;
	size_t	split_len;

	split_len = split_length(s, c);
	split = malloc(sizeof(char *) * (split_len + 1));
	malloc_strs(s, c, split, split_len);
	fill_strs(s, c, split, split_len);
	return (split);
}
// 실패 케이스들
// 1. "      ", ' ' -> "","","","","" 원래는 split 길이가 1
// 2. "  abc  def  ", ' ' -> " "," ","abc"... 원래는 c가 연속인 부분은 없애야 함
// 3. " abd def ", 'z' -> "" s에 c가 없으므로 s 그대로 반환해야 함
// -> bus error
// 4. "lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse", ' '
// -> 마지막 string 길이가 424 가 나옴 malloc_strs 를 고쳐야 함

static size_t	split_length(char const *s, char c)
{
	size_t	split_len;
	size_t	i;

	i = 0;
	split_len = 0;
	if (i == 0 && s[i] == c)
		i++;
	while (s[i])
	{
		if (s[i] == c && s[i - 1] != c)
			split_len++;
		else if (s[i + 1] == 0 && s[i] != c)
			split_len++;
		i++;
	}
  printf("split_len : %zu\n", split_len);
	return (split_len);
}

static void		malloc_strs(char const *s, char c,
		char **split, size_t split_len)
{
	size_t	i;
	size_t	j;
	size_t	k;

	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c && s[i])
		{
			i++;
			j++;
		}
		if (s[i] == c || s[i + 1] == 0)
		{
			split[k] = malloc(sizeof(char) * (j + 1));
			printf("%zu\n", j);
      j = 0;
			i++;
			k++;
		}
	}
	//split[k] = malloc(sizeof(char) * (j + 1));
}

static	void	fill_strs(char const *s, char c, char **split, size_t split_len)
{
	size_t	i;
	size_t	j;
	size_t	k;

	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c)
		{
			split[k][j] = s[i];
			j++;
			i++;
		}
		if (s[i] == c) // s의 마지막 문자가 c 가 아닌 경우를 고려하지 않는다.
		{
			j = 0;
			k++;
			i++;
		}
	}
	split[k] = NULL;
}

char			**ft_split(char const *s, char c)
{
	char	**split;
	size_t	split_len;

	split_len = split_length(s, c);
	split = malloc(sizeof(char *) * (split_len + 1));
	malloc_strs(s, c, split, split_len);
	fill_strs(s, c, split, split_len);
	return (split);
}

// ~~주어진 메모리 범위를 넘지 않도록 해야 함  s[i + 1] 같은 접근이 없어야 함~~ -> s 길이를 구해서 이용하자.
// -> 메모리 범위 넘어서 접근해도 되는 듯
// 각 string 끝에 null 붙여야 함 -> 모든 에러의 원인이었음
```

```jsx
// VAAAAV

#include "libft.h"

static size_t	split_length(char const *s, char c)
{
	size_t	split_len;
	size_t	s_len;
	size_t	i;

	s_len = ft_strlen((const char *)s);
	i = 0;
	split_len = 0;
	if (i == 0 && s[i] == c)
		i++;
	while (s[i])
	{
		if (s[i] == c && s[i - 1] != c)
			split_len++;
		else if ((i + 1 == s_len) && (s[i] != c))
			split_len++;
		i++;
	}
	return (split_len);
}

static void		malloc_strs(char const *s, char c,
		char **split, size_t split_len)
{
	size_t	s_len;
	size_t	i;
	size_t	j;
	size_t	k;

	s_len = ft_strlen((const char *)s);
	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c && s[i])
		{
			i++;
			j++;
		}
		if ((s[i] == c) || (i == s_len))
		{
			split[k] = malloc(sizeof(char) * (j + 1));
			j = 0;
			i++;
			k++;
		}
	}
}

static	void	fill_strs(char const *s, char c, char **split, size_t split_len)
{
	size_t	i;
	size_t	j;
	size_t	k;

	i = 0;
	j = 0;
	k = 0;
	while (k < split_len && s[i])
	{
		while (s[i] == c)
			i++;
		while (s[i] != c && s[i])
		{
			split[k][j] = s[i];
			j++;
			i++;
		}
		j = 0;
		k++;
		i++;
	}
	split[k] = NULL;
}

char			**ft_split(char const *s, char c)
{
	char	**split;
	size_t	split_len;

	split_len = split_length(s, c);
	split = malloc(sizeof(char *) * (split_len + 1));
	malloc_strs(s, c, split, split_len);
	fill_strs(s, c, split, split_len);
	return (split);
}
```

## libft-unit-test

# 주의사항

malloc 할 때 명시적 형변환?

# 질문

What is static function in c?

[https://stackoverflow.com/questions/558122/what-is-a-static-function-in-c](https://stackoverflow.com/questions/558122/what-is-a-static-function-in-c)

- libft.h 에 include 해야하는 라이브러리를 모두 적어놓아도 되는가?